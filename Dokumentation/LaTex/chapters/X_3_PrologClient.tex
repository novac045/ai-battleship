\subsection{Client - Prolog} \label{sec:Prologclient}
	Die Aufgaben des Prolog-Clients sind in verschiedene Module unterteilt, um die verschiedenen Teile austauschbar zu halten. 
	Im Folgenden werden die Aufgaben und die Funktionsweise dieser Module erläutert.
	
	\todoin{Gesamtübersicht - Bild - Modulzusammenspiel?}



\subsubsection{Hauptmodul}
	Das Hauptmodul \texttt{main.pl} wird beim starten des Clients aufgerufen. Das Modul initialisiert zunächst die Verbindung zum
	Spielserver. Anschließend werden Spielvorbereitungen über das Prädikat \texttt{initPrologClient/0} aus dem 
	Initialisierungsmodul getroffen (siehe Abschnitt \ref{sec:initModule}).
	
	Je nachdem ob der Client im Angriffs- oder Verteidigungsmodus startet, werden die Prädikate \texttt{attackFirst/0} oder
	\texttt{defendFirst/0} aufgerufen. Nach Empfang des Startsignals beginnt der Client dann mit einem Angriff oder Verteidigung.
	
	Ein Angriff verwendet die Prädikate \texttt{doAttack/2} und \texttt{attackResponse/3} des Angriffsmoduls (siehe Abschnitt
	\ref{sec:attackModule}).
	Das Prädikat \texttt{doAttack/2} liefert den Punkt auf dem gegnerischen Spielfeld der angegriffen werden soll.
	Die so erhaltenen X-Y-Koordinaten gibt das Hauptmodul an den Server weiter und wartet anschließend auf eine Antwort des 
	Gegners (über den Server). 
	Nach Erhalt dieser Antwort verwendet das Hauptmodul das Prädikat \texttt{attackResponse/3}, um die Antwort zu verarbeiten.
	Mit Abschluss der Verarbeitung ist der Angriff beendet.
	
	Die Verteidigung verwendet das Prädikat \texttt{doDefend/3} des Verteidigungsmoduls (siehe Abschnitt \ref{sec:defendModule}).
	Zu Beginn der Verteidigung wartet das Hauptmodul zunächst auf den Angriff des Gegners. Die so erhaltenen Koordinaten
	werden an das Prädikat \texttt{doDefend/3} übergeben. Als Resultat liefert dieses Prädikat die entsprechende Antwort für den
	Gegner. Das Hauptmodul sendet die Antwort gemäß dem Kommunikationsprotokoll an den Server. Damit ist die Verteidigung 
	beendet.
	
	Nach jedem Angriff überprüft der Client, ob er das Spiel gewonnen hat. Gleichermaßen überprüft er nach jeder Verteidigung, 
	ob er das Spiel verloren hat. Tritt einer der beiden Fälle in Kraft, so beendet sich der Client mit einer der beiden Ausgaben
	\textit{KI wins. End of game.} oder \textit{KI looses. End of game.}.
	

\subsubsection{Initialisierungsmodul} \label{sec:initModule}
	Die Aufgaben des Initialisierungsmoduls \texttt{initModule.pl} sind das initialisieren der Spielfelder, darunter auch
	das Platzieren der eigenen Schiffe. Hierzu werden die Prädikate \texttt{initMyField/0} und \texttt{initEnemyField/0} verwendet.
	
	Die verwendeten Spielfelder werden global in den dynamischen Prädikaten \texttt{myField/1} und \texttt{enemyField/1}
	gespeichert, um einen einfachen Zugriff von jedem Modul zu ermöglichen. 
	
	Das Initialisierungsmodul initialisiert außerdem die ebenfalls global gespeicherte Openlist, 
	die vom Strategiemodul verwendet wird (siehe Abschnitt \ref{sec:strategy}). 

	\todoin{Bogi - dein initships modul einbringen}

\subsubsection{Modul zur Plazierung von Schiffen} \label{sec:initships}	
	\todoin{Bogi - TODO}
	
\subsubsection{Verteidigungsmodul} \label{sec:defendModule}
	Die Aufgabe des Verteidigungsmoduls \texttt{defendModule.pl} ist es einen Angriff des Gegners zu verarbeiten.
	Zum einen muss dabei der Status des eigenen Feldes \texttt{myField/1} aktualisiert 
	und zum anderen die Antwort für den Gegner bestimmt werden.
	
	Hat der Gegner ins Wasser geschossen, so ist keine Änderung des eigenen Feldes notwendig. Trifft der Gegner jedoch ein Schiff,
	so muss ermittelt werden, ob dieser Treffer das Schiff lediglich getroffen oder sogar versenkt hat. Außerdem ändert sich die Antwort
	für den Gegner, wenn das letzte Schiff versenkt wurde.
	
	Ob das letzte Schiff versenkt wurde, erfolgt mit Hilfe einer Abfrage nach verbleibenden Schiffen (Feldstatus 6) im Prädikat \texttt{myField/1}.
	
	Die Überprüfung, ob ein Schiff vollständig versenkt wurde, erfolgt über eine rekursive Überprüfung der 4 benachbarten Felder.
	Dabei erhöht sich die Rekursionstiefe, wenn ein Nachbarfeld ebenfalls als getroffen markiert ist. 
	Da in den Regeln festgelegt ist, dass Schiffe sich nicht berühren dürfen, kann mit diesem Vorgehen festgestellt werden, ob ein Schiff
	vollständig versenkt wurde, oder sich unter den Nachbarn noch ungetroffene Teile befinden.
	
	Schlägt die zuletzt erläuterte Überprüfung fehl, so wurde nur ein Teil eines Schiffes getroffen. Und die entsprechende Antwort wird zurück 
	gegeben.
	
	\todoin{Ne schöne Grafik?}
	
	
\subsubsection{Angriffsmodul} \label{sec:attackModule}
	Die Aufgabe des Angriffsmoduls \texttt{attackModule.pl} ist es, eine Koordinate für den nächsten Angriff zu liefern und außerdem den 
	Rückgabewert des Angriffs zu verarbeiten. 
	Dafür werden die Prädikate \texttt{doAttack/2} und \texttt{attackResponse/3} verwendet. 
	
	Wird das Prädikat \texttt{doAttack} aufgerufen, so nutzt das Angriffsmodul zunächst das Prädikat \texttt{getPointOfAttack/2} des
	Strategiemoduls, um den als nächstes zu attackierenden Punkt zu erhalten. Anschließend überprüft \texttt{doAttack/2} 
	ob die erhaltene Koordinate im Feld des Gegners \texttt{enemyField/1} als unbekannt (Status 0) gilt (Prädikat \texttt{doAttackCheck}. 
	Ist dies nicht der Fall, so wird eine neue Koordinate von \texttt{getPointOfAttack/2} angefordert. 
	Gilt die Koordinate als unbekannt, so wird dieser Punkt als nächster Angriffspunkt zurück gegeben.
	
	Das Prädikat \texttt{attackResponse/3} verarbeitet die Antwort des Gegners auf einen Angriff. Zum einen wird das intern gehaltene, 
	gegnerische Feld aktualisiert (\texttt{updateEnemyField/3}), zum anderen wird die Openlist für weitere Angriffe über 
	das Prädikat \texttt{updateOpenList/3} aus dem Strategiemodul aktualisiert (siehe Abschnitt \ref{sec:strategy}).
	
	Zur Aktualisierung des gegnerischen Spielfeldes \texttt{enemyField/1} wird der vom Gegener erhaltene Status in das entsprechende 
	Feld eingetragen. Eine Ausnahme besteht für die Antwort \textit{Schiff vollständig versenkt}, in diesem Fall wird das ensprechende
	Feld lediglich mit dem Status \textit{Treffer} belegt, um die Handhabung des Spielfeldes zu erleichtern. 

\subsubsection{Strategiemodul} \label{sec:strategy}

	\begin{table}[H]
	\centering
		\begin{tabular} { | l | l |}
		\hline
		Prädikat & Verwendung \\
		\hline
		 &  \\
		\hline
		Schnittstellenprädikate & verwendet von \\
		\hline
		\end{tabular}
	\end{table}
	
	Das Strategiemodul \texttt{strategy.pl} stellt das Prädikat zur Bestimmung des nächsten Angriffspunktes \texttt{getPointOfAttack/2}
	zur Verfügung. Außerdem füllt dieses Modul die Liste der priorisiert anzugreifenden Punkte über das Prädikat \texttt{updateOpenList/3}. 
	
	Beim Aufruf von \texttt{getPointOfAttack/2} wird das erste Element der Openlist \texttt{openList/2} zurückgegeben.
	Befinden sich keine Koordinaten in der Openlist \texttt{openList/1}, so gibt \texttt{getPointOfAttack/2} einen zufälligen Angriffspunkt zurück.
	
	Das Prädikat \texttt{updateOpenList/3} erhält die angegriffene Koordinate und den vom Gegner erhaltenen Rückgabewert. 
	Traf der Angriff Wasser oder das letzte Schiff des Gegners, so erfolgt keine Änderung der Openlist.
	
	Wurde das gerade attackierte Schiff vollständig versenkt, so kann die aktuelle Openlist vollständig geleert werden, da stets nur ein 
	Schiff attackiert wird. Außerdem werden die unmittelbar benachbarten Felder des versenkten Schiffes als \textit{Wasser} markiert, denn
	Aufgrund der Spielregeln darf sich auf diesen Feldern kein weiteres Schiff befinden (Prädikat \texttt{surroundWithWater}). 
	
	Ist die Antwort des Gegeners \textit{Treffer}, so muss die OpenList aktualisiert werden. 
	Dazu werden zunächst alle benachbarten Felder in die Openlist eingetragen, deren Status unbekannt ist 
	(Prädikat \texttt{appendFreeFieldToList/2}). 
	Anschließend wird mit dem Prädikat \texttt{checkHitDirection/2} überprüft, ob die Orientierung 
	des attackierten Schiffes (horizontal oder vertikal) bereits durch frühere Treffer bekannt ist. 
	Ist dies der Fall, so kann die Openlist entsprechend um auszuschließende Positionen verkürzt werden.

\subsubsection{Ausgabemodul}
	Das Ausgabemodul \texttt{outputModule.pl} beinhaltet Prädikate zur Ausgabe der \textit{globalen Variablen} \texttt{myField/1},
	\texttt{enemyField/1} sowie \texttt{openList/1}. Die Ausgabe erfolgt auf der Standardausgabe und kann während des Spiels oder zu
	Debugzwecken verwendet werden.
	
	\todoin{Bogi - bitte vervollständigen, du wolltest da noch was adden (13.1.11)}
	\todoin{Alle - haben wir schon ne Lösung, um den Output komfortabel umzustellen, wenn wir 100x spiele gegen die andere KI machen?}

